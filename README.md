# NKU-OS-ucore
练习2: 父进程复制自己的内存空间给子进程（需要编码）
补充copy_range的实现，简要说明设计实现过程。
在 uCore 操作系统中，创建子进程的 `do_fork` 函数需要实现一个核心功能，即复制当前进程（父进程）的用户内存地址空间到新进程（子进程），以便子进程能够从父进程复制所有有效的用户空间内存内容。这个操作实际上是复制父进程的内存映射，并将这些映射应用于子进程，使得子进程拥有与父进程相同的内存内容。

### `copy_range` 函数的作用

`copy_range` 函数的主要作用是复制父进程的用户空间内存到子进程，它通过以下步骤来完成任务：
1. **检查对齐和有效范围**：确保 `start` 和 `end` 地址都是页对齐的，并且处于用户空间的有效地址范围内。
2. **遍历每一页**：根据 `start` 和 `end` 的范围，按页遍历父进程的地址空间。
3. **查找父进程的页表项**：通过 `get_pte` 函数获取父进程中对应虚拟地址 `start` 的页表项（PTE）。
4. **查找子进程的页表项**：如果父进程的页表项有效（即 PTE 中的有效位 `PTE_V` 被设置），则查找子进程相同虚拟地址的页表项。如果子进程的页表项不存在，则分配一个新的页表项。
5. **复制内存内容**：找到父进程页面后，分配一个新的页面给子进程，并将父进程页面的内容复制到子进程的页面中。
6. **建立映射关系**：使用 `page_insert` 函数将复制后的新页面映射到子进程的虚拟地址空间。

### `do_fork` 的实现

`do_fork` 函数是用来创建子进程的，具体实现过程中需要将父进程的用户空间内存内容复制到子进程。它会调用 `copy_range` 来完成内存复制的工作。`do_fork` 的基本步骤如下：

1. **创建新的进程**：首先为子进程分配进程结构 `struct proc_struct`，并初始化相关信息（如进程 ID、父进程指针、状态等）。
2. **复制父进程的资源**：复制父进程的资源，包括文件描述符、信号等。对于内存资源，则调用 `copy_mm` 函数来复制父进程的内存管理结构。
3. **调用 `copy_mm`**：`copy_mm` 函数负责复制父进程的内存空间到子进程，它会调用 `dup_mmap`，后者会调用 `copy_range` 来复制内存页内容。
4. **执行内存复制**：`copy_range` 会按页复制父进程的内存到子进程，并建立页表映射。

### `do_fork` 中如何调用 `copy_range`

```c
int do_fork(struct proc_struct *parent) {
    struct proc_struct *child;
    int ret;

    // 创建一个新的进程
    child = alloc_proc();
    if (child == NULL) {
        return -E_NO_MEM;
    }

    // 复制父进程的进程资源
    child->parent = parent;
    child->pid = alloc_pid();
    child->state = PROC_RUNNING;

    // 复制父进程的内存空间
    ret = copy_mm(child);
    if (ret != 0) {
        return ret;
    }

    // 设置调度器
    schedule();

    return 0;
}
```

### `copy_mm` 和 `dup_mmap`

`copy_mm` 函数是负责复制父进程的内存管理结构，并在新进程（子进程）中创建一个新的页表。`dup_mmap` 函数则负责遍历父进程的内存区域，并调用 `copy_range` 来复制具体的内存页内容。

```c
int copy_mm(struct proc_struct *child) {
    int ret;

    // 复制父进程的页表
    ret = dup_mmap(child);
    if (ret != 0) {
        return ret;
    }

    return 0;
}

int dup_mmap(struct proc_struct *child) {
    // 调用 copy_range 来复制父进程的内存
    return copy_range(child->mm->pgdir, current->mm->pgdir, USER_START, USER_END, false);
}
```

在 `dup_mmap` 中，`copy_range` 被用来按页复制父进程的内存内容到子进程中。

### `copy_range` 中复制的具体过程

1. **父进程的页表项 `ptep`**：通过 `get_pte` 函数查找父进程虚拟地址对应的页表项。
2. **子进程的页表项 `nptep`**：为子进程分配一个新的页表项，并将父进程的页表项复制到新的页表中。
3. **内存复制**：调用 `memcpy` 函数将父进程的页面内容复制到子进程的页面。
4. **建立页表映射**：通过 `page_insert` 函数将复制的页面映射到子进程的页表中。

### 总结

`do_fork` 函数的目的是通过复制父进程的用户空间内存，创建一个新的子进程。它通过调用 `copy_mm` 和 `dup_mmap`，进而调用 `copy_range` 函数，按页复制父进程的内存内容到子进程。这些操作确保了子进程在启动时能够拥有与父进程相同的内存内容，从而能够正确执行。

说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？
在 uCore 操作系统中，用户程序是通过 `execve` 系统调用加载到内存中的。具体过程如下：

### 1. **加载时机**
用户程序会在执行 `execve` 系统调用时被加载到内存中。`execve` 是一个由用户态发起的系统调用，通常由用户程序通过内联汇编或系统调用接口触发。以下是相关过程：
   - 用户进程通过 `execve` 请求内核执行新的程序。
   - 内核处理该请求时，会首先释放当前进程的资源（如虚拟内存空间、页目录等），然后将新的用户程序加载到当前进程的虚拟内存中。

在内核代码中，`kernel_execve` 会触发 `syscall`，最终调用 `do_execve` 函数来完成新的程序的加载。程序二进制文件（`binary`）和相关的信息（如程序的路径名 `name`）会作为参数传递给内核。内核通过 `load_icode` 等函数，将用户程序的二进制代码加载到当前进程的内存中。

### 2. **与常用操作系统加载的区别**
常见的操作系统（如 Linux、Windows 等）在加载用户程序时，通常使用更为复杂的加载机制，包括：
   - **内核加载程序**：操作系统内核会负责在用户请求时将程序从磁盘加载到内存。这通常涉及到读取 ELF 或 PE 格式的可执行文件，解析程序的头部信息，分配合适的内存空间，将程序的代码段、数据段等加载到进程的虚拟内存空间。
   - **程序分配内存**：操作系统会分配合适的虚拟内存空间给用户程序，支持动态链接库（DLL）或共享库（shared libraries）的加载，并且可能使用分页机制来按需加载程序的不同部分（如 Linux 的 `demand paging`）。
   - **原因**：uCore 是一个简化的教学操作系统，还未实现文件系统功能和磁盘管理，所以只能采用这种方式模拟用户程序的加载。

